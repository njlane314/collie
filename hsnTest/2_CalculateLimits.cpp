/* This script calculates and saves to file CL distributions.
It is hard-coded to take in input files generated by the previous step.
*/

#include <TFile.h>
#include <TTree.h>
#include <CrossSectionLimit.hh>
#include <CollieLoader.hh>
#include <FitTest.hh>
#include <CLfast.hh>
#include <CLsyst.hh>
#include <CLfit.hh>
#include <CLfit2.hh>
#include <sys/time.h>

int main(int argc, char* argv[])
{
  std::string label = std::string(argv[1]);
  std::string treatment = std::string(argv[2]);
  int massName = atoi(argv[3]);
  int run = atoi(argv[4]);
  float factor = atof(argv[5]);
  int sigma = atoi(argv[6]);

  // Choose a systematics treatment
  //                       CLfast clcompute;
  //                  CLsyst clcompute;
  //                CLfit2 clcompute;
       CLfit clcompute;

  //turn of stats thing for now
      
  clcompute.setNoviceFlag(false);
  clcompute.useHistoStats(true);

  // Create the cross section limit class and adjust settings
  // This class is used only to calculate the scaling factor to be assigned to the signal in order to obtain the 95% CL
  CrossSectionLimit csLim;
  csLim.setup(&clcompute); 
  csLim.setVerbose(false); 

  csLim.setCLlevel(0.90); // The confidence level
  csLim.setAccuracy(0.001); // The range of CL values that will satisfy the algorithm: -0.001 < (CL-0.95) < 0.001
  csLim.setPrecision(2); //4 the most precise , 0 the least
  if(sigma>-3 && sigma<3)
  {
    printf("Calculating for EXPECTED with sigma %i\n", sigma);
    csLim.calculateExpected(true);
    csLim.calculateObserved(false);  
    csLim.setNSigma(sigma);
  }
  if(sigma==-9)
  {
    printf("Calculating for OBSERVED (sigma 0)\n");
    csLim.calculateExpected(false);
    csLim.calculateObserved(true);
    csLim.setNSigma(0);
  }
  csLim.setSearchSeed(1.0);

  // This class is used to test the fit used by the CLfit and CLfit2 classes
  //  Use this to determine the quality of your fit model.
  FitTest fitTest;
  // Set the number of pseudo-experiments to fit
  fitTest.setIterations(2000);
  // Determine if you want fitted pseudo-experiments in the tests
  fitTest.testPE(true);

  // Open input file and put all information in a CollieLoader
  CollieLoader loaders[300];
  std::string chanNames[300];
  std::string fileNames[300];
  char options[1024];

  stringstream outString;
  outString << "/pc2014-data5/nlane/hnl/collie/hsnTest/Storage/CollieLimits/CollieClOutput_" << label << "_" << treatment << "_m" << massName << "_r" << run <<  "_f" << factor << "_s" << sigma <<".root";
  TString outName(outString.str().c_str());

  // Loop for each masspoint and perform calculation ( Owen: we only do one at once so got rid of loop)
  int i =0;

  SigBkgdDist* sbd;

  // Create list of mass point indices
  //int len=loaders[0].getNMasspoints(); //this is always gonna be 1
  int len=1;
  int *v1; v1 = new int[len];
  int *v2; v2 = new int[len];
  int *v3; v3 = new int[len];

  if(run==99)
  {
    std::cout<<"comb"<<std::endl;

    stringstream inString1;
    inString1 << "/pc2014-data5/nlane/hnl/collie/hsnTest/Storage/CollieFiles/CollieIOfile_" << label << "_m" << massName << "_r" << 1 << ".root";
    TString inName1(inString1.str().c_str());

    stringstream inString2;
    inString2 << "/pc2014-data5/nlane/hnl/collie/hsnTest/Storage/CollieFiles/CollieIOfile_" << label << "_m" << massName << "_r" << 3 << ".root";
    TString inName2(inString2.str().c_str());

    TFile* ftest1 = new TFile(inName1);
    chanNames[0] = ftest1->GetListOfKeys()->At(0)->GetName();
    TFile* ftest2 = new TFile(inName2);
    chanNames[1] = ftest2->GetListOfKeys()->At(0)->GetName();
    std::cout<<chanNames[0]<<","<<chanNames[1] <<std::endl;

    fileNames[0] = inName1.Data();
    sprintf(options,"name='%s'",chanNames[0].c_str());
    loaders[0].open(inName1,options);

    fileNames[1] = inName2.Data();
    sprintf(options,"name='%s'",chanNames[1].c_str());
    loaders[1].open(inName2,options);

    ftest1->Close();
    ftest1->Delete();

    ftest2->Close();
    ftest2->Delete();

    loaders[0].getMasspointList(len,v1,v2,v3);
    loaders[1].getMasspointList(len,v1,v2,v3);

    // Extract the signal & background distributions associated with this point
    sbd = loaders[0].get(v1[i],v2[i],v3[i]);
    printf("Run1; Sig: %f, Bkgd: %f, Data: %f\n",sbd->totSignal(),sbd->totBkgd(),sbd->totData()); 
    SigBkgdDist* sbd1 = loaders[1].get(v1[i],v2[i],v3[i]);
    printf("Run3; Sig: %f, Bkgd: %f, Data: %f\n",sbd1->totSignal(),sbd1->totBkgd(),sbd1->totData()); 
    sbd->append(*sbd1);
  }
  else
  {
    stringstream inString;
    inString << "/pc2014-data5/nlane/hnl/collie/hsnTest/Storage/CollieFiles/CollieIOfile_" << label << "_m" << massName << "_r" << run << ".root";
    TString inName(inString.str().c_str());
    TFile* ftest = new TFile(inName);
    chanNames[0] = ftest->GetListOfKeys()->At(0)->GetName();
    std::cout<<chanNames[0] <<std::endl;
    fileNames[0] = inName.Data();
    sprintf(options,"name='%s'",chanNames[0].c_str());
    loaders[0].open(inName,options);
    ftest->Close();
    ftest->Delete();

    loaders[0].getMasspointList(len,v1,v2,v3);

    sbd = loaders[0].get(v1[i],v2[i],v3[i]);
  }
  
  // Open output file to store results
  TFile f(outName,"RECREATE");
  TTree t("SCAN","SCAN");
  CLpoint clresults;
  clresults.branch(&t);

  // Pass the pointers to the container
  clresults.reset(v1[i],v2[i],v3[i]);

  printf("Calculating for parameters: %d/%d/%d\n",v1[i],v2[i],v3[i]);
  printf("Fina; Sig: %f, Bkgd: %f, Data: %f\n",sbd->totSignal(),sbd->totBkgd(),sbd->totData());
  // Test the fit
  // fitTest.runTest(sbd,1e6);

  // You can manually scale the signal to check where you can achieve 95% CL
  double scalingFactor = factor;
  sbd->scaleSignal(scalingFactor);
  fitTest.runTest(sbd,1e6);
  // Use the clcompute class to calculate CLs and assign results to clresults class, then print results
  clcompute.calculateCLs(*sbd,clresults,CLcompute::LEVEL_STANDARD); //this doesnt matter much just calucautes the CLs at the input scaling level.
  // clcompute.calculateCLs(*sbd,clresults,CLcompute::LEVEL_VERYVERYFINE);

  clresults.print();

  // Save LLR histograms
  char *histname = new char[50];
  int bins = 500;
  double min = -50;
  double max = 50;
  std::cout<<"i"<<i<<std::endl;
  sprintf(histname,"LLR_SB_%i",i);
  TH1D* sigLLR = clcompute.getLLRdist_sb(histname,bins,min,max);
  sprintf(histname,"LLR_B_%i",i);
  TH1D* bkgLLR = clcompute.getLLRdist_b(histname,bins,min,max);
  std::cout << "isthis doing owt" << std::endl;
  std::cout << sigLLR << std::endl;
  std::cout << bkgLLR << std::endl;
  sprintf(histname,"LLR_D_%i",i);
  TH1D* LLRd = new TH1D(histname,histname,bins,min,max);
  sprintf(histname,"LLR_B_1sigmas_%i",i);
  TH1D* LLRsigma1 = new TH1D(histname,histname,bins,min,max);
  sprintf(histname,"LLR_B_2sigmas_%i",i);
  TH1D* LLRsigma2 = new TH1D(histname,histname,bins,min,max);
  LLRd->Fill(clresults.llrobs);
  LLRsigma2->Fill(clresults.llrb_m2s);
  LLRsigma1->Fill(clresults.llrb_m1s);
  LLRsigma1->Fill(clresults.llrb_p1s);
  LLRsigma2->Fill(clresults.llrb_p2s);

  // Calculate a cross section limit and print results
  /*These results are reported in the factor by which you must
  multiply your nominal signal cross section to obtain a 95% CL
  upper limit for this model... IE, multiply this factor by
  your model xsec to get your limit in barns. */
  csLim.calculate(*sbd,clresults);
  csLim.print();

  t.Fill();

  delete sbd;

  f.Write();
  // delete [] v1;
  // delete [] v2;
  // delete [] v3;
}
