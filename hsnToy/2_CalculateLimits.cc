/* This script calculates and saves to file CL distributions.
It is hard-coded to take in input files generated by the previous step.
*/

#include <TFile.h>
#include <TTree.h>
#include <CrossSectionLimit.hh>
#include <CollieLoader.hh>
#include <FitTest.hh>
#include <CLfast.hh>
#include <CLsyst.hh>
#include <CLfit.hh>
#include <CLfit2.hh>
#include <sys/time.h>


int main()
{
  // Settings
  TString inName("/pc2014-data5/sporzio/collie/hsnTest/Storage/toyHSN_CollieIOfile.root");
  TString outName("/pc2014-data5/sporzio/collie/hsnTest/Storage/toyHSN_ClOutput.root");

  // Open input file and put all information in a CollieLoader
  CollieLoader loaders[300];
  std::string chanNames[300];
  std::string fileNames[300];
  char options[1024];
  TFile* ftest = new TFile(inName);
  TList* aList = ftest->GetListOfKeys();
  chanNames[0] = aList->At(0)->GetName();
  fileNames[0] = inName.Data();
  sprintf(options,"name='%s'",chanNames[0].c_str());
  loaders[0].open(inName,options);
  aList->Delete();
  ftest->Close();
  ftest->Delete();

  // Open output file to store results
  TFile f(outName,"RECREATE");
  TTree t("SCAN","SCAN");
  CLpoint clresults;
  clresults.branch(&t);

  // Choose a systematics treatment
  // CLfast clcompute;
  CLsyst clcompute;
  // CLfit2 clcompute;
  // CLfit clcompute;
  clcompute.setNoviceFlag(false);
  clcompute.useHistoStats(true);

  // Create the cross section limit class and adjust settings
  // This class is used only to calculate the scaling factor to be assigned to the signal in order to obtain the 95% CL
  CrossSectionLimit csLim;
  csLim.setup(&clcompute); 
  csLim.setVerbose(false); 
  csLim.setCLlevel(0.95); 
  csLim.setAccuracy(0.001); 
  csLim.setPrecision(0); 
  csLim.calculateExpected(true);  
  csLim.calculateObserved(true);
  csLim.setNSigma(0);
  csLim.setSearchSeed(1.0);


  // Create list of mass point indices
  int len=loaders[0].getNMasspoints();
  printf("Obtained %i mass points.\n", len);
  int *v1; v1 = new int[len];
  int *v2; v2 = new int[len];
  int *v3; v3 = new int[len];
  loaders[0].getMasspointList(len,v1,v2,v3);
 
  // Loop for each masspoint and perform calculation
  for (int i=0; i<len; i++)
  {
    // Pass the pointers to the container
    clresults.reset(v1[i],v2[i],v3[i]);
    
    // Extract the signal & background distributions associated with this point
    SigBkgdDist* sbd = loaders[0].get(v1[i],v2[i],v3[i]);
    printf("Calculating for parameters: %d/%d/%d\n",v1[i],v2[i],v3[i]);     
    printf("Sig: %f, Bkgd: %f, Data: %f\n",sbd->totSignal(),sbd->totBkgd(),sbd->totData()); 

    // You can manually scale the signal to check where you can achieve 95% CL
    double scalingFactor = 2.3;
    sbd->scaleSignal(scalingFactor);

    // Use the clcompute class to calculate CLs and assign results to clresults class, then print results
    clcompute.calculateCLs(*sbd,clresults,CLcompute::LEVEL_VERYFAST);
    clresults.print();

    // Save LLR histograms
    char *histname = new char[50];
    int bins = 500;
    double min = -15;
    double max = 15;

    sprintf(histname,"LLR_SB_%i",i);
    TH1D* sigLLR = clcompute.getLLRdist_sb(histname,bins,min,max);
    sprintf(histname,"LLR_B_%i",i);
    TH1D* bkgLLR = clcompute.getLLRdist_b(histname,bins,min,max);
    std::cout << sigLLR << std::endl;
    std::cout << bkgLLR << std::endl;
    sprintf(histname,"LLR_D_%i",i);
    TH1D* LLRd = new TH1D(histname,histname,bins,min,max);
    sprintf(histname,"LLR_B_1sigmas_%i",i);
    TH1D* LLRsigma1 = new TH1D(histname,histname,bins,min,max);
    sprintf(histname,"LLR_B_2sigmas_%i",i);
    TH1D* LLRsigma2 = new TH1D(histname,histname,bins,min,max);
    LLRd->Fill(clresults.llrobs);
    LLRsigma2->Fill(clresults.llrb_m2s);
    LLRsigma1->Fill(clresults.llrb_m1s);
    LLRsigma1->Fill(clresults.llrb_p1s);
    LLRsigma2->Fill(clresults.llrb_p2s);


    // Calculate a cross section limit and print results
    /*These results are reported in the factor by which you must
    multiply your nominal signal cross section to obtain a 95% CL
    upper limit for this model... IE, multiply this factor by
    your model xsec to get your limit in barns. */
    csLim.calculate(*sbd,clresults);
    csLim.print();

    t.Fill();
    delete sbd;
  }

  f.Write();
  delete [] v1;
  delete [] v2;
  delete [] v3;

}
